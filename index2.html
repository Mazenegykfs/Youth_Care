<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Column Selector & Exporter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2fe; /* Light blue background */
            margin: 0;
            padding: 0;
        }
        .header-bar {
            background-color: #1e3a8a; /* Darker blue for header */
            color: white;
            padding: 1rem;
            text-align: center;
            font-weight: 700;
            font-size: 1.25rem;
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .main-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
        .action-button {
            background-color: #10b981; /* Green for accept/execute */
            color: white;
            font-weight: 600;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
            font-size: 1.1rem;
        }
        .action-button:hover {
            background-color: #059669;
        }
        .action-button:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        .red-button {
            background-color: #ef4444; /* Red for cancel/delete/stop */
            color: white;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        .red-button:hover {
            background-color: #dc2626;
        }
        .column-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #bfdbfe; /* Lighter blue for column items */
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-weight: 500;
            cursor: grab;
        }
        .column-item.selected {
            background-color: #93c5fd; /* A bit darker blue for selected */
            border: 2px solid #3b82f6;
        }
        .column-control-button {
            background-color: #3b82f6; /* Blue for controls */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .column-control-button:hover {
            background-color: #2563eb;
        }
        .section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background-color: #f8fafc;
            border-radius: 0.75rem;
            border: 2px solid #e2e8f0;
        }
        .section h2 {
            color: #1e3a8a;
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }
        .column-list {
            border: 2px solid #cbd5e1;
            border-radius: 0.5rem;
            padding: 1rem;
            height: 300px;
            overflow-y: auto;
            background-color: white;
        }
        .table-container {
            overflow-x: auto;
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            margin-top: 1rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 0.75rem;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #d1e5f8;
        }
        th {
            background-color: #a7d9fc;
            font-weight: 600;
            color: #1f2937;
        }
        tr:nth-child(even) {
            background-color: #e3f5fe;
        }
        tr:hover {
            background-color: #d1ecfd;
        }
        .loading {
            display: none;
            text-align: center;
            margin-top: 15px;
            color: #3b82f6;
            font-weight: 600;
        }
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status-message {
            text-align: center;
            margin-top: 15px;
            padding: 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
        }
        .status-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }
        .status-error {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }
        .status-info {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }
        .file-input {
            width: 100%;
            padding: 1rem;
            border: 2px dashed #cbd5e1;
            border-radius: 0.5rem;
            background-color: white;
            font-size: 1rem;
            cursor: pointer;
        }
        .file-input:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        .hidden {
            display: none;
        }
        h1 {
            text-align: center;
            color: #1e3a8a;
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }
        h3 {
            color: #1e40af;
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        .move-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: flex-end;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        .control-group label {
            font-weight: 500;
        }
        .control-group select, .control-group input {
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #cbd5e1;
        }
        .control-group input[type="radio"] {
            margin-right: 0.5rem;
        }
        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: 1fr;
            }
            .button-group {
                flex-direction: column;
            }
            .action-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1>Column Selection and Data Export</h1>

        <section class="section">
            <h2>Upload Your Data File</h2>
            <input type="file" id="fileInput" accept=".csv, .xlsx" class="file-input" />
        </section>

        <section id="columnSelectionSection" class="section hidden">
            <h2>Select and Order Columns</h2>
            <div class="grid-container">
                <div>
                    <h3>Available Columns</h3>
                    <div id="availableColumnsList" class="column-list">
                        <!-- Available columns will be populated here -->
                    </div>
                </div>
                <div>
                    <h3>Selected Columns (Order)</h3>
                    <div id="selectedColumnsList" class="column-list">
                        <!-- Selected and ordered columns will be populated here -->
                    </div>
                    <div class="move-buttons">
                        <button id="moveUpBtn" class="column-control-button">‚ñ≤ Move Up</button>
                        <button id="moveDownBtn" class="column-control-button">‚ñº Move Down</button>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 1.5rem;">
                <button id="displayTableBtn" class="action-button">Display Table</button>
            </div>
        </section>

        <section id="resultSection" class="section hidden">
            <h2>Results Table</h2>
            <div class="control-group">
                <label for="sortColumn">Sort By:</label>
                <select id="sortColumn">
                    <option value="">(None)</option>
                </select>
                <input type="radio" id="sortAsc" name="sortDirection" value="asc" checked>
                <label for="sortAsc">Asc</label>
                <input type="radio" id="sortDesc" name="sortDirection" value="desc">
                <label for="sortDesc">Desc</label>
            </div>
            <div class="control-group">
                <label for="fontSizeInput">PPTX Font Size:</label>
                <input type="number" id="fontSizeInput" value="12" min="8" max="24">
            </div>
            <div class="button-group">
                <button id="exportXLSXBtn" class="action-button">Export to XLSX</button>
                <button id="copyTableBtn" class="action-button">Copy Table</button>
                <button id="exportPPTXBtn" class="action-button" disabled>Export to PPTX</button>
            </div>
            <div class="table-container">
                <table id="dataTable">
                    <thead>
                        <tr id="tableHeaderRow">
                            <!-- Table headers will be inserted here -->
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Table data will be inserted here -->
                    </tbody>
                </table>
            </div>
            <div class="loading" id="loadingIndicator">
                <div class="loading-spinner"></div>
                <p>Generating PowerPoint file...</p>
            </div>
            <div class="status-message status-info" id="pptStatusMessage"></div>
        </section>
    </div>

    <!-- Scripts loaded in correct order with proper error handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Load PptxGenJS dynamically with better error handling
        function loadPptxGenJS() {
            return new Promise((resolve, reject) => {
                if (window.PptxGenJS) {
                    resolve(window.PptxGenJS);
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js';
                script.onload = () => {
                    if (window.PptxGenJS) {
                        resolve(window.PptxGenJS);
                    } else {
                        reject(new Error('PptxGenJS not found after loading'));
                    }
                };
                script.onerror = () => reject(new Error('Failed to load PptxGenJS'));
                document.head.appendChild(script);
            });
        }

        // Wait for DOM and all resources to be ready
        document.addEventListener('DOMContentLoaded', function() {
            let rawData = [];
            let allHeaders = [];
            let selectedHeaders = [];
            let sortedData = [];
            let currentlySelectedColumnElement = null;
            let pptxReady = false;

            // Get DOM elements
            const fileInput = document.getElementById('fileInput');
            const columnSelectionSection = document.getElementById('columnSelectionSection');
            const availableColumnsList = document.getElementById('availableColumnsList');
            const selectedColumnsList = document.getElementById('selectedColumnsList');
            const moveUpBtn = document.getElementById('moveUpBtn');
            const moveDownBtn = document.getElementById('moveDownBtn');
            const displayTableBtn = document.getElementById('displayTableBtn');
            const resultSection = document.getElementById('resultSection');
            const tableHeaderRow = document.getElementById('tableHeaderRow');
            const tableBody = document.getElementById('tableBody');
            const exportXLSXBtn = document.getElementById('exportXLSXBtn');
            const copyTableBtn = document.getElementById('copyTableBtn');
            const exportPPTXBtn = document.getElementById('exportPPTXBtn');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const pptStatusMessage = document.getElementById('pptStatusMessage');
            const sortColumnSelect = document.getElementById('sortColumn');
            const fontSizeInput = document.getElementById('fontSizeInput');

            // Load PptxGenJS library
            loadPptxGenJS().then(() => {
                pptxReady = true;
                pptStatusMessage.textContent = 'PowerPoint library loaded successfully. Ready to export.';
                pptStatusMessage.className = 'status-message status-success';
                exportPPTXBtn.disabled = false;
            }).catch(error => {
                console.error('Failed to load PptxGenJS:', error);
                pptStatusMessage.textContent = 'PowerPoint library failed to load. PPTX export unavailable.';
                pptStatusMessage.className = 'status-message status-error';
                exportPPTXBtn.disabled = true;
            });

            // Helper function to convert Excel date serials to JavaScript Date objects
            function excelDateToJSDate(excelSerial) {
                if (typeof excelSerial !== 'number' || excelSerial <= 0) {
                    return null;
                }

                let days = excelSerial;
                if (days > 60) {
                    days--;
                }

                const msPerDay = 24 * 60 * 60 * 1000;
                const excelEpoch = new Date('1899-12-30T00:00:00.000Z');
                const jsDate = new Date(excelEpoch.getTime() + (days * msPerDay));
                return jsDate;
            }

            // Helper function to format date strings robustly
            function formatDate(value) {
                if (value === null || value === undefined || String(value).trim() === '') {
                    return '';
                }

                let date;
                let dateString = String(value).trim();

                if (typeof value === 'number' && value > 1 && value < 2958466) {
                    date = excelDateToJSDate(value);
                } else {
                    function tryParseStringDate(str) {
                        let matchYMD = str.match(/^(\d{4})[/-](\d{1,2})[/-](\d{1,2})([\sT].*)?$/);
                        if (matchYMD) {
                            let d = new Date(matchYMD[1], matchYMD[2] - 1, matchYMD[3]);
                            if (!isNaN(d.getTime())) return d;
                        }

                        let matchDMY = str.match(/^(\d{1,2})[/-](\d{1,2})[/-](\d{4})([\sT].*)?$/);
                        if (matchDMY) {
                            let d = new Date(matchDMY[3], matchDMY[2] - 1, matchDMY[1]);
                            if (!isNaN(d.getTime())) return d;
                        }

                        let matchMDY = str.match(/^(\d{1,2})[/-](\d{1,2})[/-](\d{4})([\sT].*)?$/);
                        if (matchMDY) {
                            let d = new Date(matchMDY[3], matchMDY[1] - 1, matchMDY[2]);
                            if (!isNaN(d.getTime())) return d;
                        }

                        let d = new Date(str);
                        if (!isNaN(d.getTime())) return d;
                        return null;
                    }
                    date = tryParseStringDate(dateString);
                }

                if (date) {
                    return date.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                }
                return '';
            }

            // File upload handler
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = e.target.result;
                    const fileName = file.name;

                    if (fileName.endsWith('.csv')) {
                        parseCSV(data);
                    } else if (fileName.endsWith('.xlsx')) {
                        parseXLSX(data);
                    } else {
                        // Use custom message instead of alert
                        const customAlert = document.createElement('div');
                        customAlert.classList.add('status-message', 'status-error');
                        customAlert.textContent = 'Please upload a CSV or XLSX file.';
                        document.querySelector('.main-container').appendChild(customAlert);
                        setTimeout(() => customAlert.remove(), 3000);
                    }
                };

                if (file.name.endsWith('.xlsx')) {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            });

            // Parse CSV data
            function parseCSV(data) {
                Papa.parse(data, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rawData = results.data;
                        allHeaders = results.meta.fields;
                        initializeColumnSelectors();
                    },
                    error: function(err) {
                        // Use custom message instead of alert
                        const customAlert = document.createElement('div');
                        customAlert.classList.add('status-message', 'status-error');
                        customAlert.textContent = 'Error parsing CSV: ' + err.message;
                        document.querySelector('.main-container').appendChild(customAlert);
                        setTimeout(() => customAlert.remove(), 3000);
                    }
                });
            }

            // Parse XLSX data
            function parseXLSX(data) {
                try {
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];

                    let headerRow = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 0 })[0];
                    if (headerRow && headerRow.length > 0) {
                        allHeaders = headerRow;
                        rawData = XLSX.utils.sheet_to_json(worksheet, { header: allHeaders, raw: false, defval: null });
                    } else {
                        allHeaders = [];
                        rawData = [];
                        // Use custom message instead of alert
                        const customAlert = document.createElement('div');
                        customAlert.classList.add('status-message', 'status-error');
                        customAlert.textContent = 'XLSX file is empty or has no identifiable headers.';
                        document.querySelector('.main-container').appendChild(customAlert);
                        setTimeout(() => customAlert.remove(), 3000);
                    }
                    initializeColumnSelectors();
                } catch (error) {
                    // Use custom message instead of alert
                    const customAlert = document.createElement('div');
                    customAlert.classList.add('status-message', 'status-error');
                    customAlert.textContent = 'Error parsing XLSX: ' + error.message;
                    document.querySelector('.main-container').appendChild(customAlert);
                    setTimeout(() => customAlert.remove(), 3000);
                    console.error('XLSX parse error:', error);
                }
            }

            // Initialize column selectors and sorting options
            function initializeColumnSelectors() {
                availableColumnsList.innerHTML = '';
                selectedColumnsList.innerHTML = '';
                sortColumnSelect.innerHTML = '<option value="">(None)</option>';
                selectedHeaders = [];
                columnSelectionSection.classList.remove('hidden');
                resultSection.classList.add('hidden');

                allHeaders.forEach(header => {
                    // Populate available columns list
                    const item = document.createElement('div');
                    item.classList.add('column-item');
                    item.innerHTML = `
                        <span>${header}</span>
                        <button class="column-control-button add-to-selected">Add</button>
                    `;
                    item.dataset.header = header;
                    availableColumnsList.appendChild(item);

                    // Populate sort dropdown
                    const option = document.createElement('option');
                    option.value = header;
                    option.textContent = header;
                    sortColumnSelect.appendChild(option);
                });

                availableColumnsList.querySelectorAll('.add-to-selected').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const header = e.target.closest('.column-item').dataset.header;
                        if (!selectedHeaders.includes(header)) {
                            selectedHeaders.push(header);
                            renderSelectedColumns();
                        }
                    });
                });
            }

            // Render selected columns
            function renderSelectedColumns() {
                selectedColumnsList.innerHTML = '';
                selectedHeaders.forEach(header => {
                    const item = document.createElement('div');
                    item.classList.add('column-item', 'draggable');
                    item.innerHTML = `
                        <span>${header}</span>
                        <button class="red-button remove-from-selected">Remove</button>
                    `;
                    item.dataset.header = header;
                    selectedColumnsList.appendChild(item);

                    item.addEventListener('click', (e) => {
                        if (e.target.classList.contains('remove-from-selected')) return;
                        if (currentlySelectedColumnElement) {
                            currentlySelectedColumnElement.classList.remove('selected');
                        }
                        currentlySelectedColumnElement = item;
                        item.classList.add('selected');
                    });
                });

                selectedColumnsList.querySelectorAll('.remove-from-selected').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const headerToRemove = e.target.closest('.column-item').dataset.header;
                        selectedHeaders = selectedHeaders.filter(h => h !== headerToRemove);
                        renderSelectedColumns();
                        if (currentlySelectedColumnElement && currentlySelectedColumnElement.dataset.header === headerToRemove) {
                            currentlySelectedColumnElement = null;
                        }
                    });
                });
            }
            
            // Function to sort data
            function sortData(data, column, direction) {
                if (!column) return data;
                
                const sorted = [...data].sort((a, b) => {
                    const valA = a[column];
                    const valB = b[column];
                    
                    if (valA === null || valA === undefined) return 1;
                    if (valB === null || valB === undefined) return -1;

                    if (typeof valA === 'string' && typeof valB === 'string') {
                        return valA.localeCompare(valB, 'en-US', { sensitivity: 'base' });
                    }
                    
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    return 0;
                });
                return sorted;
            }

            // Move column up
            moveUpBtn.addEventListener('click', () => {
                if (currentlySelectedColumnElement) {
                    const header = currentlySelectedColumnElement.dataset.header;
                    const index = selectedHeaders.indexOf(header);
                    if (index > 0) {
                        [selectedHeaders[index], selectedHeaders[index - 1]] = [selectedHeaders[index - 1], selectedHeaders[index]];
                        renderSelectedColumns();
                        const newElement = selectedColumnsList.querySelector(`[data-header="${header}"]`);
                        if (newElement) {
                            newElement.classList.add('selected');
                            currentlySelectedColumnElement = newElement;
                        }
                    }
                }
            });

            // Move column down
            moveDownBtn.addEventListener('click', () => {
                if (currentlySelectedColumnElement) {
                    const header = currentlySelectedColumnElement.dataset.header;
                    const index = selectedHeaders.indexOf(header);
                    if (index < selectedHeaders.length - 1) {
                        [selectedHeaders[index], selectedHeaders[index + 1]] = [selectedHeaders[index + 1], selectedHeaders[index]];
                        renderSelectedColumns();
                        const newElement = selectedColumnsList.querySelector(`[data-header="${header}"]`);
                        if (newElement) {
                            newElement.classList.add('selected');
                            currentlySelectedColumnElement = newElement;
                        }
                    }
                }
            });

            // Display table
            displayTableBtn.addEventListener('click', () => {
                if (selectedHeaders.length === 0) {
                    // Use a custom message instead of alert
                    const customAlert = document.createElement('div');
                    customAlert.classList.add('status-message', 'status-error');
                    customAlert.textContent = 'Please select at least one column.';
                    document.querySelector('.main-container').appendChild(customAlert);
                    setTimeout(() => customAlert.remove(), 3000);
                    return;
                }

                tableHeaderRow.innerHTML = '';
                tableBody.innerHTML = '';

                // Get sorting options
                const sortColumn = sortColumnSelect.value;
                const sortDirection = document.querySelector('input[name="sortDirection"]:checked').value;
                
                // Sort the data based on selection
                sortedData = sortData(rawData, sortColumn, sortDirection);

                const dateTimeColumns = ['ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ÿßŸÑŸä)', 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ŸÖŸÜ)', 'ŸàŸÇÿ™ ÿßŸÑÿ®ÿØÿ°', 'ŸàŸÇÿ™ ÿßŸÑÿ•ŸÉŸÖÿßŸÑ'];

                selectedHeaders.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    tableHeaderRow.appendChild(th);
                });

                sortedData.forEach(row => {
                    const tr = document.createElement('tr');
                    selectedHeaders.forEach(header => {
                        const td = document.createElement('td');
                        let cellValue = row[header] !== undefined ? row[header] : '';

                        if (dateTimeColumns.includes(header)) {
                            cellValue = formatDate(cellValue);
                        }
                        td.textContent = cellValue;
                        tr.appendChild(td);
                    });
                    tableBody.appendChild(tr);
                });

                resultSection.classList.remove('hidden');
                loadingIndicator.style.display = 'none';

                // Enable PPTX button if library is ready
                if (pptxReady && window.PptxGenJS) {
                    exportPPTXBtn.disabled = false;
                    pptStatusMessage.textContent = 'PowerPoint library ready. You can now export to PPTX.';
                    pptStatusMessage.className = 'status-message status-success';
                } else {
                    exportPPTXBtn.disabled = true;
                    pptStatusMessage.textContent = 'PowerPoint library not ready. Please wait or refresh the page.';
                    pptStatusMessage.className = 'status-message status-error';
                }
            });

            // Copy table to clipboard
            copyTableBtn.addEventListener('click', () => {
                let tableText = '';
                Array.from(tableHeaderRow.children).forEach((th, index) => {
                    tableText += th.textContent + (index < tableHeaderRow.children.length - 1 ? '\t' : '');
                });
                tableText += '\n';

                Array.from(tableBody.children).forEach(row => {
                    Array.from(row.children).forEach((td, index) => {
                        tableText += td.textContent + (index < row.children.length - 1 ? '\t' : '');
                    });
                    tableText += '\n';
                });

                // Use a custom message instead of alert
                // In a real app, this would be a modal
                const customMessage = document.createElement('div');
                customMessage.classList.add('status-message', 'status-info');
                try {
                    // Modern approach
                    navigator.clipboard.writeText(tableText).then(() => {
                        customMessage.textContent = 'Table copied to clipboard!';
                    }).catch(err => {
                        console.error('Failed to copy using modern API: ', err);
                        // Fallback to older method
                        const textarea = document.createElement('textarea');
                        textarea.value = tableText;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        customMessage.textContent = 'Table copied to clipboard!';
                    });
                } catch (e) {
                     // Fallback to older method
                     const textarea = document.createElement('textarea');
                     textarea.value = tableText;
                     document.body.appendChild(textarea);
                     textarea.select();
                     document.execCommand('copy');
                     document.body.removeChild(textarea);
                     customMessage.textContent = 'Table copied to clipboard!';
                }
                document.querySelector('.main-container').appendChild(customMessage);
                setTimeout(() => customMessage.remove(), 3000);
            });

            // Export to XLSX
            exportXLSXBtn.addEventListener('click', () => {
                if (selectedHeaders.length === 0) {
                    // Use a custom message instead of alert
                    const customAlert = document.createElement('div');
                    customAlert.classList.add('status-message', 'status-error');
                    customAlert.textContent = 'No data to export. Please display the table first.';
                    document.querySelector('.main-container').appendChild(customAlert);
                    setTimeout(() => customAlert.remove(), 3000);
                    return;
                }

                const dataToExport = [selectedHeaders];
                const dateTimeColumns = ['ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ÿßŸÑŸä)', 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ŸÖŸÜ)', 'ŸàŸÇÿ™ ÿßŸÑÿ®ÿØÿ°', 'ŸàŸÇÿ™ ÿßŸÑÿ•ŸÉŸÖÿßŸÑ'];

                sortedData.forEach(row => {
                    const newRow = selectedHeaders.map(header => {
                        let cellValue = row[header] !== undefined ? row[header] : '';
                        if (dateTimeColumns.includes(header)) {
                            cellValue = formatDate(cellValue);
                        }
                        return cellValue;
                    });
                    dataToExport.push(newRow);
                });

                const ws = XLSX.utils.aoa_to_sheet(dataToExport);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
                XLSX.writeFile(wb, "exported_data.xlsx");
            });

            // Export to PPTX
            exportPPTXBtn.addEventListener('click', async () => {
                if (selectedHeaders.length === 0) {
                    // Use a custom message instead of alert
                    const customAlert = document.createElement('div');
                    customAlert.classList.add('status-message', 'status-error');
                    customAlert.textContent = 'No data to export. Please display the table first.';
                    document.querySelector('.main-container').appendChild(customAlert);
                    setTimeout(() => customAlert.remove(), 3000);
                    return;
                }

                if (!pptxReady || !window.PptxGenJS) {
                    const customAlert = document.createElement('div');
                    customAlert.classList.add('status-message', 'status-error');
                    customAlert.textContent = 'PowerPoint generation is not available. Please wait for the library to load or refresh the page.';
                    document.querySelector('.main-container').appendChild(customAlert);
                    setTimeout(() => customAlert.remove(), 3000);
                    return;
                }

                pptStatusMessage.textContent = '';
                loadingIndicator.style.display = 'block';
                exportPPTXBtn.disabled = true;

                setTimeout(async () => {
                    try {
                        let pptx = new PptxGenJS();
                        pptx.layout = 'LAYOUT_WIDE';
                        const pptxFontSize = parseInt(fontSizeInput.value, 10);

                        // Define slide master for all slides
                        pptx.defineSlideMaster({
                            title: 'UNIVERSAL_HEADER_MASTER',
                            background: { fill: 'FFFFFF' },
                            objects: [
                                {
                                    rect: {
                                        x: 0, y: 0, w: '100%', h: 0.8,
                                        fill: { color: '1E3A8A' }
                                    }
                                },
                                {
                                    text: 'ÿßŸÑŸÖÿπŸáÿØ ÿßŸÑÿπÿßŸÑŸä ŸÑŸÑŸáŸÜÿØÿ≥ÿ© ŸàÿßŸÑÿ™ŸÉŸÜŸàŸÑŸàÿ¨Ÿäÿß ÿ®ŸÉŸÅÿ± ÿßŸÑÿ¥ŸäÿÆ',
                                    options: {
                                        x: 0,
                                        y: 0,
                                        w: '100%',
                                        h: 0.8,
                                        fontSize: 18,
                                        color: 'FFFFFF',
                                        align: 'center',
                                        valign: 'middle',
                                        rtl: true,
                                        bold: true
                                    }
                                }
                            ]
                        });

                        const dateTimeColumns = ['ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ÿßŸÑŸä)', 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ (ŸÖŸÜ)', 'ŸàŸÇÿ™ ÿßŸÑÿ®ÿØÿ°', 'ŸàŸÇÿ™ ÿßŸÑÿ•ŸÉŸÖÿßŸÑ'];

                        // Filter data with content
                        const dataToPresent = sortedData.filter(row =>
                            selectedHeaders.some(header => row[header] !== undefined && String(row[header]).trim() !== '')
                        );

                        if (dataToPresent.length === 0) {
                            pptStatusMessage.textContent = 'No data with content to generate slides for.';
                            pptStatusMessage.className = 'status-message status-error';
                            loadingIndicator.style.display = 'none';
                            exportPPTXBtn.disabled = false;
                            return;
                        }

                        // Create one slide per record
                        dataToPresent.forEach((row, recordIndex) => {
                            // Create the main data slide using the defined master
                            let slide = pptx.addSlide({ masterName: 'UNIVERSAL_HEADER_MASTER' });
                            
                            // Create a details table for this record
                            const recordTableData = [];

                            selectedHeaders.forEach(header => {
                                let cellValue = row[header] !== undefined ? row[header] : '';
                                
                                // Format dates
                                if (dateTimeColumns.includes(header)) {
                                    cellValue = formatDate(cellValue);
                                }

                                // Create table row with VALUE first (right side), then LABEL (left side) for RTL layout
                                recordTableData.push([
                                    {
                                        text: String(cellValue),
                                        options: {
                                            fontFace: 'Arial',
                                            fontSize: pptxFontSize,
                                            color: '1F2937',
                                            fill: 'FFFFFF',
                                            align: 'right', // Always align right for RTL
                                            valign: 'top',
                                            rtl: true, // Enable RTL for all content
                                            margin: [0.1, 0.1, 0.1, 0.1],
                                            breakLine: true
                                        }
                                    },
                                    {
                                        text: header,
                                        options: {
                                            bold: true,
                                            fontFace: 'Arial',
                                            fontSize: pptxFontSize + 2,
                                            color: '1E3A8A',
                                            fill: 'A7D9FC',
                                            align: 'right', // Always align right for RTL
                                            valign: 'middle',
                                            rtl: true, // Enable RTL for all headers
                                            margin: [0.1, 0.1, 0.1, 0.1]
                                        }
                                    }
                                ]);
                            });

                            // Add the details table with RTL column order and a black border
                            slide.addTable(recordTableData, {
                                x: 0.8,
                                y: 1.4,
                                w: 11.4,
                                h: 5.2,
                                border: { pt: 1, color: '000000' }, // Set border to black
                                colW: [7.6, 3.8], // 67% for values (right), 33% for labels (left)
                                rowH: recordTableData.map(() => {
                                    // Calculate row height based on content length
                                    return 0.4; // Default row height, could be adjusted
                                }),
                                autoPage: false,
                                fill: 'F8FAFC',
                                rtl: true // Enable RTL for the entire table
                            });

                        });

                        await pptx.writeFile({ fileName: 'detailed-records-report.pptx' });
                        pptStatusMessage.textContent = 'ÿ™ŸÖ ÿ™ŸÜÿ≤ŸäŸÑ ŸÖŸÑŸÅ PowerPoint ÿ®ŸÜÿ¨ÿßÿ≠! - PowerPoint file downloaded successfully! üéâ';
                        pptStatusMessage.className = 'status-message status-success';
                    } catch (error) {
                        console.error("Error generating PowerPoint file:", error);
                        pptStatusMessage.textContent = `ÿÆÿ∑ÿ£ ŸÅŸä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ PowerPoint - Error generating PowerPoint file: ${error.message}`;
                        pptStatusMessage.className = 'status-message status-error';
                    } finally {
                        loadingIndicator.style.display = 'none';
                        exportPPTXBtn.disabled = false;
                    }
                }, 100);
            });
        });
    </script>
</body>
</html>
